From a63ff8c78839595aee8b00f9504805e05bfc2771 Mon Sep 17 00:00:00 2001
From: root <you@example.com>
Date: Thu, 7 Dec 2023 09:07:34 +0200
Subject: [PATCH] Added monitoring command fizzbuzz

---
 hmp-commands-info.hx    |  13 +++
 monitor/hmp-cmds.c      |  11 ++
 monitor/qmp-cmds.c      |  38 +++++++
 monitor/qmp-cmds.c.save | 243 ++++++++++++++++++++++++++++++++++++++++
 qapi/misc.json          |  17 +++
 5 files changed, 322 insertions(+)
 create mode 100644 monitor/qmp-cmds.c.save

diff --git a/hmp-commands-info.hx b/hmp-commands-info.hx
index f5b37eb..cfbf7f1 100644
--- a/hmp-commands-info.hx
+++ b/hmp-commands-info.hx
@@ -26,6 +26,19 @@ ERST
         .flags      = "p",
     },
 
+SRST
+  ``info fizzbuzz``
+    Show the fizzbuzz result.
+ERST
+
+    {
+        .name       = "fizzbuzz",
+        .args_type  = "val:i?",
+        .params     = "[val]",
+        .help       = "show fizzbuzz result",
+        .cmd        = hmp_info_fizzbuzz,
+    },
+
 SRST
   ``info version``
     Show the version of QEMU.
diff --git a/monitor/hmp-cmds.c b/monitor/hmp-cmds.c
index 871898a..3b77d68 100644
--- a/monitor/hmp-cmds.c
+++ b/monitor/hmp-cmds.c
@@ -57,6 +57,17 @@ strList *hmp_split_at_comma(const char *str)
     return res;
 }
 
+void hmp_fizzbuzz(Monitor *mon, const QDict *qdict)
+{
+    int64_t val = qdict_get_try_int(qdict, "val", 10);
+    Error *err = NULL;
+
+    qmp_fizzbuzz(!!val, val, &err);
+    if (hmp_handle_error(mon, err)) {
+        return;
+    }
+}
+
 void hmp_info_name(Monitor *mon, const QDict *qdict)
 {
     NameInfo *info;
diff --git a/monitor/qmp-cmds.c b/monitor/qmp-cmds.c
index b0f948d..169ded6 100644
--- a/monitor/qmp-cmds.c
+++ b/monitor/qmp-cmds.c
@@ -41,6 +41,44 @@ NameInfo *qmp_query_name(Error **errp)
     return info;
 }
 
+bool isNumeric(const char *str): 
+{
+    while(*str != '\0')
+    {
+        if(*str < '0' || *str > '9')
+            return false;
+        str++;
+    }
+    return true;
+}
+
+void qmp_fizzbuzz(int64_t num, Error **errp)
+{
+    if isNumeric(num) != True {
+        error_setg(errp, "This is not a number");
+        return;
+    }
+
+    char *out = NULL;
+
+    if (num % 3 == 0) {
+        if (num % 5 == 0) {
+            out = "fizzbuzz";
+        } else {
+            out = "fizz";
+        }
+    } else if (num % 5 == 0) {
+        out = "buzz";
+    } else {
+        /* convert int to string */
+        int len = snprintf(NULL, 0, "%" PRId64, num);
+        out = malloc(len + 1);
+        snprintf(out, len + 1, "%" PRId64, num)
+    }
+
+    return out;
+}
+
 void qmp_quit(Error **errp)
 {
     shutdown_action = SHUTDOWN_ACTION_POWEROFF;
diff --git a/monitor/qmp-cmds.c.save b/monitor/qmp-cmds.c.save
new file mode 100644
index 0000000..167ef33
--- /dev/null
+++ b/monitor/qmp-cmds.c.save
@@ -0,0 +1,243 @@
+/*
+ * QEMU Management Protocol commands
+ *
+ * Copyright IBM, Corp. 2011
+ *
+ * Authors:
+ *  Anthony Liguori   <aliguori@us.ibm.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ * Contributions after 2012-01-13 are licensed under the terms of the
+ * GNU GPL, version 2 or (at your option) any later version.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/sockets.h"
+#include "monitor-internal.h"
+#include "monitor/qdev.h"
+#include "monitor/qmp-helpers.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/kvm.h"
+#include "sysemu/runstate.h"
+#include "sysemu/runstate-action.h"
+#include "sysemu/block-backend.h"
+#include "qapi/error.h"
+#include "qapi/qapi-init-commands.h"
+#include "qapi/qapi-commands-control.h"
+#include "qapi/qapi-commands-misc.h"
+#include "qapi/qmp/qerror.h"
+#include "qapi/type-helpers.h"
+#include "hw/mem/memory-device.h"
+#include "hw/intc/intc.h"
+#include "hw/rdma/rdma.h"
+
+NameInfo *qmp_query_name(Error **errp)
+{
+    NameInfo *info = g_malloc0(sizeof(*info));
+
+    info->name = g_strdup(qemu_name);
+    return info;
+}
+
+void qmp_fizzbuzz(int64_t num, Error **errp)
+{
+    char *out = NULL;
+
+    if (num % 3 == 0)
+    {
+        if (num % 5 == 0) {
+            out = "fizzbuzz";
+        } else {
+            out = "fizz";
+    }
+    } else if (num % 5 == 0) {
+        out = "buzz";
+    } else {
+        // Most common scenario: Convert the number to a string
+        // Using snprintf to handle the conversion
+        int len = snprintf(NULL, 0, "%" PRId64, num);
+        out = malloc(len + 1);
+        if (out != NULL) {
+            snprintf(out, len + 1, "%" PRId64, num);
+        } else {
+            // Handle memory allocation failure
+            fprintf(stderr, "Memory allocation failed\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+
+
+
+    return out;
+}
+
+void qmp_quit(Error **errp)
+{
+    shutdown_action = SHUTDOWN_ACTION_POWEROFF;
+    qemu_system_shutdown_request(SHUTDOWN_CAUSE_HOST_QMP_QUIT);
+}
+
+void qmp_stop(Error **errp)
+{
+    /* if there is a dump in background, we should wait until the dump
+     * finished */
+    if (qemu_system_dump_in_progress()) {
+        error_setg(errp, "There is a dump in process, please wait.");
+        return;
+    }
+
+    if (runstate_check(RUN_STATE_INMIGRATE)) {
+        autostart = 0;
+    } else {
+        vm_stop(RUN_STATE_PAUSED);
+    }
+}
+
+void qmp_cont(Error **errp)
+{
+    BlockBackend *blk;
+    BlockJob *job;
+    Error *local_err = NULL;
+
+    /* if there is a dump in background, we should wait until the dump
+     * finished */
+    if (qemu_system_dump_in_progress()) {
+        error_setg(errp, "There is a dump in process, please wait.");
+        return;
+    }
+
+    if (runstate_needs_reset()) {
+        error_setg(errp, "Resetting the Virtual Machine is required");
+        return;
+    } else if (runstate_check(RUN_STATE_SUSPENDED)) {
+        return;
+    } else if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {
+        error_setg(errp, "Migration is not finalized yet");
+        return;
+    }
+
+    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {
+        blk_iostatus_reset(blk);
+    }
+
+    WITH_JOB_LOCK_GUARD() {
+        for (job = block_job_next_locked(NULL); job;
+             job = block_job_next_locked(job)) {
+            block_job_iostatus_reset_locked(job);
+        }
+    }
+
+    /* Continuing after completed migration. Images have been inactivated to
+     * allow the destination to take control. Need to get control back now.
+     *
+     * If there are no inactive block nodes (e.g. because the VM was just
+     * paused rather than completing a migration), bdrv_inactivate_all() simply
+     * doesn't do anything. */
+    bdrv_activate_all(&local_err);
+    if (local_err) {
+        error_propagate(errp, local_err);
+        return;
+    }
+
+    if (runstate_check(RUN_STATE_INMIGRATE)) {
+        autostart = 1;
+    } else {
+        vm_start();
+    }
+}
+
+void qmp_add_client(const char *protocol, const char *fdname,
+                    bool has_skipauth, bool skipauth, bool has_tls, bool tls,
+                    Error **errp)
+{
+    static const struct {
+        const char *name;
+        bool (*add_client)(int fd, bool has_skipauth, bool skipauth,
+                           bool has_tls, bool tls, Error **errp);
+    } protocol_table[] = {
+        { "spice", qmp_add_client_spice },
+#ifdef CONFIG_VNC
+        { "vnc", qmp_add_client_vnc },
+#endif
+#ifdef CONFIG_DBUS_DISPLAY
+        { "@dbus-display", qmp_add_client_dbus_display },
+#endif
+    };
+    int fd, i;
+
+    fd = monitor_get_fd(monitor_cur(), fdname, errp);
+    if (fd < 0) {
+        return;
+    }
+
+    if (!fd_is_socket(fd)) {
+        error_setg(errp, "parameter @fdname must name a socket");
+        close(fd);
+        return;
+    }
+
+    for (i = 0; i < ARRAY_SIZE(protocol_table); i++) {
+        if (!strcmp(protocol, protocol_table[i].name)) {
+            if (!protocol_table[i].add_client(fd, has_skipauth, skipauth,
+                                              has_tls, tls, errp)) {
+                close(fd);
+            }
+            return;
+        }
+    }
+
+    if (!qmp_add_client_char(fd, has_skipauth, skipauth, has_tls, tls,
+                             protocol, errp)) {
+        close(fd);
+    }
+}
+
+char *qmp_human_monitor_command(const char *command_line, bool has_cpu_index,
+                                int64_t cpu_index, Error **errp)
+{
+    char *output = NULL;
+    MonitorHMP hmp = {};
+
+    monitor_data_init(&hmp.common, false, true, false);
+
+    if (has_cpu_index) {
+        int ret = monitor_set_cpu(&hmp.common, cpu_index);
+        if (ret < 0) {
+            error_setg(errp, QERR_INVALID_PARAMETER_VALUE, "cpu-index",
+                       "a CPU number");
+            goto out;
+        }
+    }
+
+    handle_hmp_command(&hmp, command_line);
+
+    WITH_QEMU_LOCK_GUARD(&hmp.common.mon_lock) {
+        output = g_strdup(hmp.common.outbuf->str);
+    }
+
+out:
+    monitor_data_destroy(&hmp.common);
+    return output;
+}
+
+static void __attribute__((__constructor__)) monitor_init_qmp_commands(void)
+{
+    /*
+     * Two command lists:
+     * - qmp_commands contains all QMP commands
+     * - qmp_cap_negotiation_commands contains just
+     *   "qmp_capabilities", to enforce capability negotiation
+     */
+
+    qmp_init_marshal(&qmp_commands);
+
+    qmp_register_command(&qmp_commands, "device_add",
+                         qmp_device_add, 0, 0);
+
+    QTAILQ_INIT(&qmp_cap_negotiation_commands);
+    qmp_register_command(&qmp_cap_negotiation_commands, "qmp_capabilities",
+                         qmp_marshal_qmp_capabilities,
+                         QCO_ALLOW_PRECONFIG, 0);
+}
diff --git a/qapi/misc.json b/qapi/misc.json
index cda2eff..62e3a61 100644
--- a/qapi/misc.json
+++ b/qapi/misc.json
@@ -8,6 +8,23 @@
 
 { 'include': 'common.json' }
 
+
+##
+# @fizzbuzz:
+#
+# Print a to the standard output stream.
+#
+# @value: int number
+#
+# Returns: String that is fizzbuzz or number.
+#
+#
+# Since: <next qemu stable release, eg. 1.0>
+##
+{ 'command': 'fizzbuzz',
+  'data': { 'value': 'int' },
+  'returns': 'str' }
+
 ##
 # @add_client:
 #
-- 
2.34.1
